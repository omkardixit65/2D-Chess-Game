<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ôüÔ∏è 2D Chess Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            transition: background 0.3s ease;
        }

        body.light-mode {
            background: linear-gradient(135deg, #ecf0f1 0%, #bdc3c7 100%);
        }

        .container {
            background: #ffffff;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
            max-width: 600px;
            width: 100%;
            position: relative;
            transition: background 0.3s ease, color 0.3s ease;
        }

        body.light-mode .container {
            background: #ffffff;
        }

        /* Settings Button */
        .settings-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 28px;
            padding: 5px;
            transition: transform 0.3s ease, opacity 0.3s ease;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-btn:hover {
            opacity: 0.7;
        }

        .settings-btn.spin {
            animation: spin 0.5s ease-in-out;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: white;
            border-radius: 20px;
            padding: 35px;
            max-width: 480px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.4s ease;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #ecf0f1;
        }

        .settings-header h2 {
            font-size: 2em;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
        }

        .settings-close {
            background: #ecf0f1;
            border: none;
            font-size: 1.5em;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 5px 12px;
            border-radius: 8px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .settings-close:hover {
            background: #e74c3c;
            color: white;
            transform: scale(1.1);
        }

        .settings-section {
            margin-bottom: 28px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-section h3 {
            font-size: 1.2em;
            color: #34495e;
            margin-bottom: 15px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 2px solid #f8f9fa;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            font-size: 1.05em;
            color: #2c3e50;
            font-weight: 600;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 54px;
            height: 28px;
            background: #bdc3c7;
            border-radius: 14px;
            cursor: pointer;
            transition: background 0.3s ease;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: #27ae60;
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(26px);
        }

        /* Rules Section */
        .rules-content {
            background: #f8f9fa;
            padding: 18px;
            border-radius: 12px;
            margin-top: 12px;
            font-size: 0.95em;
            color: #2c3e50;
            line-height: 1.7;
            max-height: 240px;
            overflow-y: auto;
            border: 2px solid #ecf0f1;
        }

        .rules-content::-webkit-scrollbar {
            width: 6px;
        }

        .rules-content::-webkit-scrollbar-track {
            background: #ecf0f1;
            border-radius: 3px;
        }

        .rules-content::-webkit-scrollbar-thumb {
            background: #95a5a6;
            border-radius: 3px;
        }

        .rules-content::-webkit-scrollbar-thumb:hover {
            background: #7f8c8d;
        }

        .rules-content h4 {
            margin-top: 12px;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 1.05em;
            font-weight: 700;
        }

        .rules-content h4:first-child {
            margin-top: 0;
        }

        .rules-content ul {
            margin-left: 22px;
            margin-top: 8px;
            margin-bottom: 8px;
        }

        .rules-content li {
            margin-bottom: 6px;
            line-height: 1.6;
        }

        .rules-content strong {
            color: #34495e;
            font-weight: 700;
        }

        /* Statistics */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 12px;
        }

        .stat-card {
            background: #ecf0f1;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: 700;
            color: #2c3e50;
        }

        .stat-label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-top: 4px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 2em;
            font-weight: 700;
        }

        .setup-panel {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .setup-panel.hidden {
            display: none;
        }

        .setup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .setup-row:last-child {
            margin-bottom: 0;
        }

        .setup-label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 1em;
            min-width: 140px;
        }

        .color-selector, .opponent-selector, .mode-selector, .difficulty-buttons, .timer-buttons {
            display: flex;
            gap: 10px;
            flex: 1;
        }

        .color-btn, .opponent-btn, .mode-btn, .difficulty-btn, .timer-btn {
            flex: 1;
            padding: 10px 20px;
            border: 2px solid #95a5a6;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            color: #2c3e50;
            text-align: center;
            font-size: 1em;
        }

        .color-btn:hover, .opponent-btn:hover, .mode-btn:hover, .difficulty-btn:hover, .timer-btn:hover {
            border-color: #2c3e50;
            transform: translateY(-2px);
        }

        .color-btn.selected, .opponent-btn.selected, .mode-btn.selected, .difficulty-btn.selected, .timer-btn.selected {
            background: #2c3e50;
            color: white;
            border-color: #2c3e50;
        }

        .name-input {
            flex: 1;
            padding: 10px 16px;
            border-radius: 8px;
            border: 2px solid #95a5a6;
            font-size: 1em;
            background: white;
            color: #2c3e50;
            font-weight: 500;
            outline: none;
            transition: border-color 0.2s ease;
        }

        .name-input:focus {
            border-color: #2c3e50;
        }

        .name-input::placeholder {
            color: #95a5a6;
        }

        .btn-start {
            width: 100%;
            padding: 14px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

        .btn-start:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
        }

        .game-panel {
            display: none;
        }

        .game-panel.active {
            display: block;
        }

        .timer-display {
            display: none;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #34495e;
            border-radius: 10px;
        }

        .timer-display.active {
            display: flex;
        }

        .game-timer {
            text-align: center;
            color: white;
        }

        .timer-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .timer-value {
            font-size: 2.5em;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            color: #2ecc71;
        }

        .timer-value.warning {
            color: #e74c3c;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #ecf0f1;
            border-radius: 10px;
        }

        .turn-indicator {
            font-weight: 700;
            font-size: 1.1em;
            color: #2c3e50;
        }

        .status {
            font-weight: 600;
            color: #7f8c8d;
        }

        .move-counter {
            text-align: center;
            font-size: 0.95em;
            color: #7f8c8d;
            margin-bottom: 15px;
            font-weight: 600;
        }

        /* Bot thinking indicator */
        .bot-thinking {
            display: none;
            text-align: center;
            margin-bottom: 15px;
            color: #3498db;
            font-weight: 600;
            animation: pulse 1.5s infinite;
        }

        .bot-thinking.active {
            display: block;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            width: 100%;
            max-width: 560px;
            margin: 0 auto;
            border: 6px solid #2c3e50;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 
                0 8px 20px rgba(0, 0, 0, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.2),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            position: relative;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.3),
                1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .square.light {
            background: linear-gradient(135deg, #f0d9b5 0%, #e8d4af 100%);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .square.dark {
            background: linear-gradient(135deg, #b58863 0%, #a67c52 100%);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.15);
        }

        .square:hover {
            filter: brightness(1.05);
            box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.2);
        }

        .square.selected {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important;
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.2),
                0 0 12px rgba(52, 152, 219, 0.5) !important;
        }

        .square.valid-move {
            background: linear-gradient(135deg, #52c97c 0%, #48b56f 100%) !important;
            box-shadow: 
                inset 0 0 15px rgba(0, 0, 0, 0.15),
                0 0 8px rgba(82, 201, 124, 0.4) !important;
        }

        .square.valid-move::after {
            content: '';
            width: 28%;
            height: 28%;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .square.last-move {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2) 0%, rgba(41, 128, 185, 0.2) 100%) !important;
            box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.3) !important;
            border: 2px solid rgba(52, 152, 219, 0.4);
        }

        .square.in-check {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
            animation: checkPulse 1s ease-in-out infinite;
        }

        @keyframes checkPulse {
            0%, 100% {
                box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2), 0 0 15px rgba(231, 76, 60, 0.6);
            }
            50% {
                box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2), 0 0 25px rgba(231, 76, 60, 0.9);
            }
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 14px 24px;
            font-size: 1.1em;
            font-weight: 700;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
        }

        .btn-new {
            background: #27ae60;
        }

        .btn-new:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
        }

        .btn-undo {
            background: #2c3e50;
        }

        .btn-undo:hover {
            background: #1a252f;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(44, 62, 80, 0.3);
        }

        .btn-undo:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-resign {
            background: #e74c3c;
        }

        .btn-resign:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .btn-draw {
            background: #3498db;
        }

        .btn-draw:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .captured-pieces {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding: 15px;
            background: #ecf0f1;
            border-radius: 10px;
        }

        .captured-section {
            flex: 1;
        }

        .captured-section h3 {
            font-size: 0.9em;
            margin-bottom: 8px;
            color: #7f8c8d;
            font-weight: 600;
        }

        .captured-list {
            font-size: 1.5em;
            min-height: 30px;
            color: #2c3e50;
        }

        .message {
            text-align: center;
            margin-top: 15px;
            font-size: 1.2em;
            font-weight: 700;
            color: #27ae60;
            min-height: 30px;
        }

        .message.checkmate {
            color: #e74c3c;
        }

        /* Footer */
        .footer {
            text-align: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px solid #ecf0f1;
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .footer a {
            color: #3498db;
            text-decoration: none;
            font-weight: 600;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Game Over Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.5s ease;
            position: relative;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-icon {
            font-size: 5em;
            margin-bottom: 20px;
            animation: bounce 1s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .modal-title {
            font-size: 2.5em;
            font-weight: 800;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .modal-title.win {
            color: #27ae60;
        }

        .modal-title.lose {
            color: #e74c3c;
        }

        .modal-title.draw {
            color: #3498db;
        }

        .modal-subtitle {
            font-size: 1.3em;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .modal-close {
            background: #27ae60;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            font-weight: 700;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        /* Confetti Animation */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #f0f;
            position: absolute;
            animation: confetti-fall 3s linear;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
                max-width: 95vw;
            }

            h1 {
                font-size: 1.6em;
                margin-bottom: 20px;
            }

            .square {
                font-size: 2.2em;
            }

            .timer-value {
                font-size: 2em;
            }

            .setup-row {
                flex-direction: column;
                align-items: stretch;
            }

            .setup-label {
                min-width: unset;
            }

            .color-selector, .opponent-selector, .mode-selector, .difficulty-buttons, .timer-buttons {
                width: 100%;
            }

            .modal-content {
                padding: 30px 20px;
            }

            .modal-icon {
                font-size: 4em;
            }

            .modal-title {
                font-size: 2em;
            }

            .modal-subtitle {
                font-size: 1.1em;
            }

            .settings-btn {
                font-size: 24px;
            }

            .settings-content {
                padding: 25px;
            }

            .settings-header h2 {
                font-size: 1.6em;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.4em;
            }

            .square {
                font-size: 1.8em;
            }

            .game-info {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }

            .timer-value {
                font-size: 1.8em;
            }

            .captured-list {
                font-size: 1.2em;
            }

            button {
                padding: 12px 18px;
                font-size: 1em;
            }

            .color-btn, .opponent-btn, .mode-btn, .difficulty-btn, .timer-btn {
                font-size: 0.9em;
                padding: 10px 15px;
            }

            .modal-icon {
                font-size: 3em;
            }

            .modal-title {
                font-size: 1.7em;
            }

            .settings-content {
                padding: 20px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }

        @media (min-width: 1024px) {
            .container {
                max-width: 650px;
            }

            .chessboard {
                max-width: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Settings Button -->
        <button class="settings-btn" id="settingsBtn" onclick="openSettings()" title="Settings (Esc)">‚öôÔ∏è</button>

        <h1>‚ôüÔ∏è 2D Chess Game</h1>
        
        <!-- Setup Panel -->
        <div class="setup-panel" id="setupPanel">
            <div class="setup-row">
                <span class="setup-label">Play Against:</span>
                <div class="opponent-selector">
                    <button class="opponent-btn selected" data-opponent="bot" onclick="selectOpponent('bot')">
                        ü§ñ Bot
                    </button>
                    <button class="opponent-btn" data-opponent="friend" onclick="selectOpponent('friend')">
                        üë• Friend
                    </button>
                </div>
            </div>

            <div class="setup-row">
                <span class="setup-label">Game Mode:</span>
                <div class="mode-selector">
                    <button class="mode-btn selected" data-mode="classic" onclick="selectMode('classic')">
                        Classic
                    </button>
                    <button class="mode-btn" data-mode="timed" onclick="selectMode('timed')">
                        ‚è± Timed
                    </button>
                </div>
            </div>

            <div class="setup-row" id="timerRow" style="display: none;">
                <span class="setup-label">Game Duration:</span>
                <div class="timer-buttons">
                    <button class="timer-btn" data-time="60" onclick="selectTimer(60)">
                        1 min
                    </button>
                    <button class="timer-btn" data-time="180" onclick="selectTimer(180)">
                        3 min
                    </button>
                    <button class="timer-btn selected" data-time="300" onclick="selectTimer(300)">
                        5 min
                    </button>
                </div>
            </div>

            <div class="setup-row" id="player1NameRow">
                <span class="setup-label" id="player1Label">Your Name:</span>
                <input type="text" id="player1Name" class="name-input" placeholder="Enter your name" maxlength="20">
            </div>

            <div class="setup-row" id="player2NameRow" style="display: none;">
                <span class="setup-label">Player 2 Name:</span>
                <input type="text" id="player2Name" class="name-input" placeholder="Enter Player 2 name" maxlength="20">
            </div>

            <div class="setup-row" id="colorRow">
                <span class="setup-label">Choose Your Color:</span>
                <div class="color-selector">
                    <button class="color-btn selected" data-color="white" onclick="selectColor('white')">
                        ‚ôî White
                    </button>
                    <button class="color-btn" data-color="black" onclick="selectColor('black')">
                        ‚ôö Black
                    </button>
                </div>
            </div>
            
            <div class="setup-row" id="difficultyRow">
                <span class="setup-label">Bot Difficulty:</span>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn" data-difficulty="1" onclick="selectDifficulty(1)">
                        Easy
                    </button>
                    <button class="difficulty-btn selected" data-difficulty="2" onclick="selectDifficulty(2)">
                        Medium
                    </button>
                    <button class="difficulty-btn" data-difficulty="3" onclick="selectDifficulty(3)">
                        Hard
                    </button>
                </div>
            </div>
            
            <button class="btn btn-start" onclick="startGame()">Start Game</button>
        </div>

        <!-- Game Panel -->
        <div class="game-panel" id="gamePanel">
            <div class="timer-display" id="timerDisplay">
                <div class="game-timer">
                    <div class="timer-label">Time Remaining</div>
                    <div class="timer-value" id="gameTimer">5:00</div>
                </div>
            </div>

            <div class="game-info">
                <div class="turn-indicator" id="turnIndicator">White's Turn</div>
                <div class="status" id="status">Game in Progress</div>
            </div>

            <div class="move-counter" id="moveCounter">Move: 0</div>

            <div class="bot-thinking" id="botThinking">ü§î Bot is thinking...</div>

            <div class="chessboard" id="chessboard"></div>

            <div class="captured-pieces">
                <div class="captured-section">
                    <h3 id="whiteCapturedLabel">White Captured:</h3>
                    <div class="captured-list" id="whiteCaptured"></div>
                </div>
                <div class="captured-section">
                    <h3 id="blackCapturedLabel">Black Captured:</h3>
                    <div class="captured-list" id="blackCaptured"></div>
                </div>
            </div>

            <div class="message" id="message"></div>

            <div class="controls">
                <button class="btn-new" onclick="newGame()">New Game</button>
                <button class="btn-undo" id="undoBtn" onclick="undoMove()" title="Undo (U)">Undo Move</button>
                <button class="btn-draw" id="drawBtn" onclick="offerDraw()">ü§ù Offer Draw</button>
                <button class="btn-resign" onclick="resignGame()" title="Resign (R)">üè≥Ô∏è Resign</button>
            </div>

            <div class="footer">
                Made with ‚ôüÔ∏è by <a href="#" id="authorLink">Omkar Dixit</a>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2>‚öôÔ∏è Settings</h2>
                <button class="settings-close" onclick="closeSettings()">√ó</button>
            </div>

            <div class="settings-section">
                <h3>üîä Sound</h3>
                <div class="setting-item">
                    <span class="setting-label">Sound Effects</span>
                    <div class="toggle-switch active" id="soundToggle" onclick="toggleSound()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3>üé® Theme</h3>
                <div class="setting-item">
                    <span class="setting-label">Light Mode</span>
                    <div class="toggle-switch" id="themeToggle" onclick="toggleTheme()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3>üìä Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="statWins">0</div>
                        <div class="stat-label">Wins</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statDraws">0</div>
                        <div class="stat-label">Draws</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statLosses">0</div>
                        <div class="stat-label">Losses</div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3>üìñ How to Play</h3>
                <div class="rules-content">
                    <h4>Basic Rules</h4>
                    <ul>
                        <li><strong>Objective:</strong> Checkmate your opponent's king</li>
                        <li><strong>Turns:</strong> White moves first, then players alternate</li>
                        <li><strong>Check:</strong> King is under threat and must move</li>
                        <li><strong>Checkmate:</strong> King cannot escape check - you win!</li>
                        <li><strong>Stalemate:</strong> No legal moves but not in check - it's a draw</li>
                        <li><strong>Insufficient Material:</strong> Not enough pieces to checkmate - it's a draw</li>
                        <li><strong>Resign:</strong> Give up the game gracefully</li>
                    </ul>
                    
                    <h4>Piece Movements</h4>
                    <ul>
                        <li><strong>‚ôô Pawn:</strong> Moves forward 1 square (2 on first move), captures diagonally</li>
                        <li><strong>‚ôú Rook:</strong> Moves any distance horizontally or vertically</li>
                        <li><strong>‚ôû Knight:</strong> Moves in L-shape (2+1 squares), can jump over pieces</li>
                        <li><strong>‚ôù Bishop:</strong> Moves any distance diagonally</li>
                        <li><strong>‚ôõ Queen:</strong> Moves any distance in any direction</li>
                        <li><strong>‚ôö King:</strong> Moves one square in any direction</li>
                    </ul>

                    <h4>Special Features</h4>
                    <ul>
                        <li><strong>Pawn Promotion:</strong> When a pawn reaches the opposite end, it becomes a Queen</li>
                        <li><strong>Valid Moves:</strong> Green dots show where you can move</li>
                        <li><strong>Last Move:</strong> Subtle blue tint shows the last move made</li>
                        <li><strong>Undo:</strong> Take back your last move (both yours and bot's)</li>
                        <li><strong>Keyboard Shortcuts:</strong> U (Undo), R (Resign), Esc (Close Settings)</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal-overlay" id="gameOverModal">
        <div class="modal-content">
            <div class="modal-icon" id="modalIcon">üèÜ</div>
            <h2 class="modal-title" id="modalTitle">Congratulations!</h2>
            <p class="modal-subtitle" id="modalSubtitle">You won the game!</p>
            <button class="modal-close" onclick="closeModal()">Play Again</button>
        </div>
    </div>

    <script>
        const PIECES = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        let board = [];
        let selectedSquare = null;
        let currentTurn = 'white';
        let moveHistory = [];
        let capturedPieces = { white: [], black: [] };
        let difficulty = 2;
        let playerColor = 'white';
        let botColor = 'black';
        let opponentType = 'bot';
        let gameMode = 'classic';
        let timerDuration = 300;
        let gameTimeLeft = 300;
        let timerInterval = null;
        let player1DisplayName = 'You';
        let player2DisplayName = 'Bot';
        let soundEnabled = true;
        let darkMode = false;
        let moveCount = 0;
        let lastMove = null;
        let gameStats = JSON.parse(localStorage.getItem('chessStats')) || { wins: 0, draws: 0, losses: 0 };

        // Audio Context for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Load stats on page load
        updateStatsDisplay();

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSettings();
            } else if (e.key.toLowerCase() === 'u' && currentTurn !== 'none') {
                undoMove();
            } else if (e.key.toLowerCase() === 'r' && currentTurn !== 'none') {
                resignGame();
            }
        });

        // Settings Functions
        function openSettings() {
            playButtonClick();
            const settingsBtn = document.getElementById('settingsBtn');
            settingsBtn.classList.add('spin');
            setTimeout(() => settingsBtn.classList.remove('spin'), 500);
            document.getElementById('settingsModal').classList.add('active');
        }

        function closeSettings() {
            playButtonClick();
            document.getElementById('settingsModal').classList.remove('active');
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const toggle = document.getElementById('soundToggle');
            toggle.classList.toggle('active');
            playButtonClick();
        }

        function toggleTheme() {
            darkMode = !darkMode;
            const toggle = document.getElementById('themeToggle');
            toggle.classList.toggle('active');
            document.body.classList.toggle('light-mode');
            playButtonClick();
        }

        function updateStatsDisplay() {
            document.getElementById('statWins').textContent = gameStats.wins;
            document.getElementById('statDraws').textContent = gameStats.draws;
            document.getElementById('statLosses').textContent = gameStats.losses;
        }

        function saveStats() {
            localStorage.setItem('chessStats', JSON.stringify(gameStats));
            updateStatsDisplay();
        }

        // Offer Draw Function
        function offerDraw() {
            if (currentTurn === 'none') return;
            
            playButtonClick();
            
            if (confirm('Are you sure you want to offer a draw?')) {
                if (opponentType === 'friend') {
                    if (confirm('Does your opponent accept the draw?')) {
                        endGameAsDraw('mutual');
                    }
                } else {
                    // Bot randomly accepts based on difficulty
                    const acceptChance = difficulty === 1 ? 0.5 : difficulty === 2 ? 0.3 : 0.1;
                    if (Math.random() < acceptChance) {
                        setTimeout(() => {
                            alert('Bot accepted the draw!');
                            endGameAsDraw('mutual');
                        }, 500);
                    } else {
                        setTimeout(() => {
                            alert('Bot declined the draw.');
                        }, 500);
                    }
                }
            }
        }

        function endGameAsDraw(reason) {
            stopTimer();
            currentTurn = 'none';
            gameStats.draws++;
            saveStats();
            
            const messageEl = document.getElementById('message');
            messageEl.textContent = 'ü§ù Draw by mutual agreement!';
            messageEl.className = 'message';
            document.getElementById('status').textContent = 'Game Over';
            showGameOverModal('draw-mutual', null);
        }

        // Resign Function
        function resignGame() {
            if (currentTurn === 'none') return;
            
            playButtonClick();
            
            if (confirm('Are you sure you want to resign?')) {
                stopTimer();
                currentTurn = 'none';
                
                const messageEl = document.getElementById('message');
                
                if (opponentType === 'friend') {
                    const resigningPlayer = currentTurn === 'white' ? player1DisplayName : player2DisplayName;
                    const winner = currentTurn === 'white' ? player2DisplayName : player1DisplayName;
                    messageEl.textContent = `${resigningPlayer} resigned. ${winner} wins!`;
                    showGameOverModal('resign', winner);
                } else {
                    gameStats.losses++;
                    saveStats();
                    messageEl.textContent = 'üè≥Ô∏è You resigned. Bot wins!';
                    showGameOverModal('resign', 'Bot');
                }
                
                messageEl.className = 'message checkmate';
                document.getElementById('status').textContent = 'Game Over';
            }
        }

        // Sound effect functions
        function playButtonClick() {
            if (!soundEnabled) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 1200;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.08);
        }

        function playPieceMove() {
            if (!soundEnabled) return;
            const bufferSize = audioContext.sampleRate * 0.15;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            filter.Q.value = 1;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
            
            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            noise.start(audioContext.currentTime);
            noise.stop(audioContext.currentTime + 0.15);
            
            const thud = audioContext.createOscillator();
            const thudGain = audioContext.createGain();
            thud.frequency.value = 80;
            thud.type = 'sine';
            thudGain.gain.setValueAtTime(0.15, audioContext.currentTime);
            thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            thud.connect(thudGain);
            thudGain.connect(audioContext.destination);
            thud.start(audioContext.currentTime);
            thud.stop(audioContext.currentTime + 0.1);
        }

        function playCapture() {
            if (!soundEnabled) return;
            const bufferSize = audioContext.sampleRate * 0.2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 600;
            filter.Q.value = 2;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.35, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            
            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            noise.start(audioContext.currentTime);
            noise.stop(audioContext.currentTime + 0.2);
            
            const thud = audioContext.createOscillator();
            const thudGain = audioContext.createGain();
            thud.frequency.value = 60;
            thud.type = 'sine';
            thudGain.gain.setValueAtTime(0.25, audioContext.currentTime);
            thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
            thud.connect(thudGain);
            thudGain.connect(audioContext.destination);
            thud.start(audioContext.currentTime);
            thud.stop(audioContext.currentTime + 0.15);
        }

        function playVictory() {
            if (!soundEnabled) return;
            const notes = [261.63, 329.63, 392.00, 523.25];
            notes.forEach((freq, i) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = freq;
                oscillator.type = 'sine';
                
                const startTime = audioContext.currentTime + (i * 0.12);
                gainNode.gain.setValueAtTime(0.12, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.4);
            });
        }

        function playDefeat() {
            if (!soundEnabled) return;
            const notes = [392.00, 349.23, 293.66, 261.63];
            notes.forEach((freq, i) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = freq;
                oscillator.type = 'sine';
                
                const startTime = audioContext.currentTime + (i * 0.12);
                gainNode.gain.setValueAtTime(0.12, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.4);
            });
        }

        function playCheckmate() {
            if (!soundEnabled) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(261.63, audioContext.currentTime + 0.6);
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.6);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.6);
        }

        function playTimeout() {
            if (!soundEnabled) return;
            for (let i = 0; i < 3; i++) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 440;
                oscillator.type = 'sine';
                
                const startTime = audioContext.currentTime + (i * 0.15);
                gainNode.gain.setValueAtTime(0.15, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.12);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.12);
            }
        }

        function playDraw() {
            if (!soundEnabled) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 392;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        function selectOpponent(type) {
            playButtonClick();
            opponentType = type;
            document.querySelectorAll('.opponent-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector(`[data-opponent="${type}"]`).classList.add('selected');
            
            if (type === 'friend') {
                document.getElementById('colorRow').style.display = 'none';
                document.getElementById('difficultyRow').style.display = 'none';
                document.getElementById('player1Label').textContent = 'Player 1 Name:';
                document.getElementById('player2NameRow').style.display = 'flex';
                document.getElementById('player1Name').placeholder = 'Enter Player 1 name';
            } else {
                document.getElementById('colorRow').style.display = 'flex';
                document.getElementById('difficultyRow').style.display = 'flex';
                document.getElementById('player1Label').textContent = 'Your Name:';
                document.getElementById('player2NameRow').style.display = 'none';
                document.getElementById('player1Name').placeholder = 'Enter your name';
            }
        }

        function selectMode(mode) {
            playButtonClick();
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector(`[data-mode="${mode}"]`).classList.add('selected');
            document.getElementById('timerRow').style.display = mode === 'timed' ? 'flex' : 'none';
        }

        function selectTimer(time) {
            playButtonClick();
            timerDuration = time;
            document.querySelectorAll('.timer-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector(`[data-time="${time}"]`).classList.add('selected');
        }

        function selectColor(color) {
            playButtonClick();
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector(`[data-color="${color}"]`).classList.add('selected');
            playerColor = color;
            botColor = color === 'white' ? 'black' : 'white';
        }

        function selectDifficulty(level) {
            playButtonClick();
            difficulty = level;
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector(`[data-difficulty="${level}"]`).classList.add('selected');
        }

        function startGame() {
            playButtonClick();
            const p1Name = document.getElementById('player1Name').value.trim();
            const p2Name = document.getElementById('player2Name').value.trim();
            
            if (opponentType === 'friend') {
                player1DisplayName = p1Name || 'Player 1';
                player2DisplayName = p2Name || 'Player 2';
            } else {
                player1DisplayName = p1Name || 'You';
                player2DisplayName = 'Bot';
            }
            
            if (gameMode === 'timed') {
                gameTimeLeft = timerDuration;
                document.getElementById('timerDisplay').classList.add('active');
                updateTimerDisplay();
            }
            
            document.getElementById('setupPanel').classList.add('hidden');
            document.getElementById('gamePanel').classList.add('active');
            initGame();
        }

        function updateCapturedLabels() {
            if (opponentType === 'friend') {
                document.getElementById('whiteCapturedLabel').textContent = `${player1DisplayName} Captured:`;
                document.getElementById('blackCapturedLabel').textContent = `${player2DisplayName} Captured:`;
            } else {
                if (playerColor === 'white') {
                    document.getElementById('whiteCapturedLabel').textContent = `${player1DisplayName} Captured:`;
                    document.getElementById('blackCapturedLabel').textContent = 'Bot Captured:';
                } else {
                    document.getElementById('whiteCapturedLabel').textContent = 'Bot Captured:';
                    document.getElementById('blackCapturedLabel').textContent = `${player1DisplayName} Captured:`;
                }
            }
        }

        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#a29bfe', '#fd79a8', '#fdcb6e'];
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    document.getElementById('gameOverModal').appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 3000);
                }, i * 30);
            }
        }

        function showGameOverModal(type, winner) {
            const modal = document.getElementById('gameOverModal');
            const icon = document.getElementById('modalIcon');
            const title = document.getElementById('modalTitle');
            const subtitle = document.getElementById('modalSubtitle');

            if (type === 'checkmate') {
                playCheckmate();
                if (opponentType === 'friend') {
                    icon.textContent = 'üèÜ';
                    title.textContent = 'Checkmate!';
                    title.className = 'modal-title win';
                    subtitle.textContent = `${winner} wins the game!`;
                    createConfetti();
                    setTimeout(playVictory, 300);
                } else {
                    if (winner === player1DisplayName) {
                        gameStats.wins++;
                        saveStats();
                        icon.textContent = 'üéâ';
                        title.textContent = 'Victory!';
                        title.className = 'modal-title win';
                        subtitle.textContent = 'Congratulations! You won by checkmate!';
                        createConfetti();
                        setTimeout(playVictory, 300);
                    } else {
                        gameStats.losses++;
                        saveStats();
                        icon.textContent = 'üòî';
                        title.textContent = 'Checkmate!';
                        title.className = 'modal-title lose';
                        subtitle.textContent = 'The bot won this time. Try again!';
                        setTimeout(playDefeat, 300);
                    }
                }
            } else if (type === 'resign') {
                if (winner === 'Bot' || winner === player2DisplayName) {
                    playDefeat();
                    icon.textContent = 'üè≥Ô∏è';
                    title.textContent = 'Resigned';
                    title.className = 'modal-title lose';
                    subtitle.textContent = `${winner} wins by resignation!`;
                } else {
                    playVictory();
                    icon.textContent = 'üèÜ';
                    title.textContent = 'Victory!';
                    title.className = 'modal-title win';
                    subtitle.textContent = `${winner} wins by resignation!`;
                    createConfetti();
                }
            } else if (type === 'stalemate' || type === 'insufficient' || type === 'draw-mutual') {
                playDraw();
                gameStats.draws++;
                saveStats();
                icon.textContent = type === 'draw-mutual' ? 'ü§ù' : type === 'insufficient' ? '‚öñÔ∏è' : 'ü§ù';
                title.textContent = 'Draw!';
                title.className = 'modal-title draw';
                subtitle.textContent = type === 'draw-mutual' ? 'Draw by mutual agreement!' : 
                                     type === 'insufficient' ? 'Insufficient material to checkmate!' : 
                                     "It's a draw! Well played!";
            } else if (type === 'timeout') {
                playTimeout();
                gameStats.losses++;
                saveStats();
                icon.textContent = '‚è±Ô∏è';
                title.textContent = "Time's Up!";
                title.className = 'modal-title lose';
                subtitle.textContent = 'The game ended due to timeout!';
            }

            modal.classList.add('active');
        }

        function closeModal() {
            playButtonClick();
            document.getElementById('gameOverModal').classList.remove('active');
            newGame();
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                gameTimeLeft--;
                if (gameTimeLeft <= 0) {
                    endGameByTimeout();
                    return;
                }
                updateTimerDisplay();
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimerDisplay() {
            const timerElement = document.getElementById('gameTimer');
            timerElement.textContent = formatTime(gameTimeLeft);
            timerElement.classList.toggle('warning', gameTimeLeft <= 30);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function endGameByTimeout() {
            stopTimer();
            const messageEl = document.getElementById('message');
            messageEl.textContent = "‚è±Ô∏è Time's Up! Game Over!";
            messageEl.className = 'message checkmate';
            document.getElementById('status').textContent = 'Game Over';
            currentTurn = 'none';
            showGameOverModal('timeout', null);
        }

        function initGame() {
            board = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
            currentTurn = 'white';
            selectedSquare = null;
            moveHistory = [];
            capturedPieces = { white: [], black: [] };
            moveCount = 0;
            lastMove = null;
            renderBoard();
            updateStatus();
            updateCapturedPieces();
            updateCapturedLabels();
            updateMoveCounter();
            document.getElementById('message').textContent = '';
            document.getElementById('undoBtn').disabled = false;

            if (gameMode === 'timed') {
                startTimer();
            }

            if (opponentType === 'bot' && playerColor === 'black') {
                setTimeout(botMove, 500);
            }
        }

        function updateMoveCounter() {
            document.getElementById('moveCounter').textContent = `Move: ${Math.floor(moveCount / 2) + 1}`;
        }

        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';

            const startRow = (opponentType === 'bot' && playerColor === 'black') ? 7 : 0;
            const endRow = (opponentType === 'bot' && playerColor === 'black') ? -1 : 8;
            const rowStep = (opponentType === 'bot' && playerColor === 'black') ? -1 : 1;

            for (let row = startRow; row !== endRow; row += rowStep) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.className += (row + col) % 2 === 0 ? ' light' : ' dark';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Highlight last move
                    if (lastMove && 
                        ((lastMove.from[0] === row && lastMove.from[1] === col) ||
                         (lastMove.to[0] === row && lastMove.to[1] === col))) {
                        square.classList.add('last-move');
                    }
                    
                    const piece = board[row][col];
                    if (piece) {
                        square.textContent = PIECES[piece];
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessboard.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (currentTurn === 'none') return;

            if (opponentType === 'friend') {
                const piece = board[row][col];
                const isCurrentPlayerPiece = piece && 
                    ((currentTurn === 'white' && isWhitePiece(piece)) || 
                     (currentTurn === 'black' && !isWhitePiece(piece)));
                
                if (selectedSquare) {
                    const [selectedRow, selectedCol] = selectedSquare;
                    const validMoves = getValidMoves(selectedRow, selectedCol);
                    
                    if (validMoves.some(move => move[0] === row && move[1] === col)) {
                        const capturedPiece = board[row][col];
                        makeMove(selectedRow, selectedCol, row, col);
                        if (capturedPiece) {
                            playCapture();
                        } else {
                            playPieceMove();
                        }
                        selectedSquare = null;
                        renderBoard();
                        checkGameEnd();
                    } else if (isCurrentPlayerPiece) {
                        selectedSquare = [row, col];
                        highlightValidMoves(row, col);
                    } else {
                        selectedSquare = null;
                        renderBoard();
                    }
                } else if (isCurrentPlayerPiece) {
                    selectedSquare = [row, col];
                    highlightValidMoves(row, col);
                }
                updateStatus();
            } else {
                if (currentTurn !== playerColor) return;

                const piece = board[row][col];
                const isPlayerPiece = piece && ((playerColor === 'white' && isWhitePiece(piece)) || 
                                               (playerColor === 'black' && !isWhitePiece(piece)));
                
                if (selectedSquare) {
                    const [selectedRow, selectedCol] = selectedSquare;
                    const validMoves = getValidMoves(selectedRow, selectedCol);
                    
                    if (validMoves.some(move => move[0] === row && move[1] === col)) {
                        const capturedPiece = board[row][col];
                        makeMove(selectedRow, selectedCol, row, col);
                        if (capturedPiece) {
                            playCapture();
                        } else {
                            playPieceMove();
                        }
                        selectedSquare = null;
                        renderBoard();
                        
                        checkGameEnd();
                        
                        if (currentTurn !== 'none' && !isCheckmate(botColor) && !isStalemate(botColor)) {
                            setTimeout(botMove, 500);
                        }
                    } else if (isPlayerPiece) {
                        selectedSquare = [row, col];
                        highlightValidMoves(row, col);
                    } else {
                        selectedSquare = null;
                        renderBoard();
                    }
                } else if (isPlayerPiece) {
                    selectedSquare = [row, col];
                    highlightValidMoves(row, col);
                }

                updateStatus();
            }
        }

        function highlightValidMoves(row, col) {
            renderBoard();
            const validMoves = getValidMoves(row, col);
            
            document.querySelector(`[data-row="${row}"][data-col="${col}"]`).classList.add('selected');
            
            validMoves.forEach(([r, c]) => {
                document.querySelector(`[data-row="${r}"][data-col="${c}"]`).classList.add('valid-move');
            });
        }

        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];

            let moves = [];
            const isWhite = isWhitePiece(piece);
            const pieceType = piece.toLowerCase();

            switch (pieceType) {
                case 'p': moves = getPawnMoves(row, col, isWhite); break;
                case 'r': moves = getRookMoves(row, col, isWhite); break;
                case 'n': moves = getKnightMoves(row, col, isWhite); break;
                case 'b': moves = getBishopMoves(row, col, isWhite); break;
                case 'q': moves = getQueenMoves(row, col, isWhite); break;
                case 'k': moves = getKingMoves(row, col, isWhite); break;
            }

            return moves.filter(([r, c]) => !wouldBeInCheck(row, col, r, c, isWhite));
        }

        function getPawnMoves(row, col, isWhite) {
            const moves = [];
            const direction = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;

            if (board[row + direction] && board[row + direction][col] === '') {
                moves.push([row + direction, col]);
                
                if (row === startRow && board[row + 2 * direction][col] === '') {
                    moves.push([row + 2 * direction, col]);
                }
            }

            [-1, 1].forEach(offset => {
                const newCol = col + offset;
                if (newCol >= 0 && newCol < 8 && board[row + direction]) {
                    const targetPiece = board[row + direction][newCol];
                    if (targetPiece && isWhitePiece(targetPiece) !== isWhite) {
                        moves.push([row + direction, newCol]);
                    }
                }
            });

            return moves;
        }

        function getRookMoves(row, col, isWhite) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            directions.forEach(([dr, dc]) => {
                let r = row + dr;
                let c = col + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    if (board[r][c] === '') {
                        moves.push([r, c]);
                    } else {
                        if (isWhitePiece(board[r][c]) !== isWhite) {
                            moves.push([r, c]);
                        }
                        break;
                    }
                    r += dr;
                    c += dc;
                }
            });

            return moves;
        }

        function getKnightMoves(row, col, isWhite) {
            const moves = [];
            const offsets = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];

            offsets.forEach(([dr, dc]) => {
                const r = row + dr;
                const c = col + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = board[r][c];
                    if (!targetPiece || isWhitePiece(targetPiece) !== isWhite) {
                        moves.push([r, c]);
                    }
                }
            });

            return moves;
        }

        function getBishopMoves(row, col, isWhite) {
            const moves = [];
            const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            directions.forEach(([dr, dc]) => {
                let r = row + dr;
                let c = col + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    if (board[r][c] === '') {
                        moves.push([r, c]);
                    } else {
                        if (isWhitePiece(board[r][c]) !== isWhite) {
                            moves.push([r, c]);
                        }
                        break;
                    }
                    r += dr;
                    c += dc;
                }
            });

            return moves;
        }

        function getQueenMoves(row, col, isWhite) {
            return [...getRookMoves(row, col, isWhite), ...getBishopMoves(row, col, isWhite)];
        }

        function getKingMoves(row, col, isWhite) {
            const moves = [];
            const offsets = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];

            offsets.forEach(([dr, dc]) => {
                const r = row + dr;
                const c = col + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const targetPiece = board[r][c];
                    if (!targetPiece || isWhitePiece(targetPiece) !== isWhite) {
                        moves.push([r, c]);
                    }
                }
            });

            return moves;
        }

        function isWhitePiece(piece) {
            return piece === piece.toUpperCase();
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];

            lastMove = {
                from: [fromRow, fromCol],
                to: [toRow, toCol],
                piece: piece,
                captured: capturedPiece,
                turn: currentTurn
            };

            moveHistory.push(lastMove);
            moveCount++;
            updateMoveCounter();

            if (capturedPiece) {
                if (isWhitePiece(capturedPiece)) {
                    capturedPieces.black.push(capturedPiece);
                } else {
                    capturedPieces.white.push(capturedPiece);
                }
                updateCapturedPieces();
            }

            if (piece.toLowerCase() === 'p') {
                if ((toRow === 0 && isWhitePiece(piece)) || (toRow === 7 && !isWhitePiece(piece))) {
                    board[toRow][toCol] = isWhitePiece(piece) ? 'Q' : 'q';
                    board[fromRow][fromCol] = '';
                    currentTurn = currentTurn === 'white' ? 'black' : 'white';
                    return;
                }
            }

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
        }

        function botMove() {
            document.getElementById('botThinking').classList.add('active');
            
            setTimeout(() => {
                const allMoves = [];
                const isBotWhite = botColor === 'white';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && isWhitePiece(piece) === isBotWhite) {
                            const moves = getValidMoves(row, col);
                            moves.forEach(([r, c]) => {
                                const score = evaluateMove(row, col, r, c);
                                allMoves.push({ from: [row, col], to: [r, c], score });
                            });
                        }
                    }
                }

                if (allMoves.length === 0) {
                    document.getElementById('botThinking').classList.remove('active');
                    checkGameEnd();
                    return;
                }

                allMoves.sort((a, b) => b.score - a.score);
                
                let selectedMove;
                if (difficulty === 1) {
                    selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                } else if (difficulty === 2) {
                    const topMoves = allMoves.slice(0, Math.max(1, Math.floor(allMoves.length * 0.3)));
                    selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)];
                } else {
                    selectedMove = allMoves[0];
                }

                const [fromRow, fromCol] = selectedMove.from;
                const [toRow, toCol] = selectedMove.to;
                
                const capturedPiece = board[toRow][toCol];
                makeMove(fromRow, fromCol, toRow, toCol);
                if (capturedPiece) {
                    playCapture();
                } else {
                    playPieceMove();
                }
                
                document.getElementById('botThinking').classList.remove('active');
                renderBoard();
                checkGameEnd();
                updateStatus();
            }, 300);
        }

        function evaluateMove(fromRow, fromCol, toRow, toCol) {
            let score = 0;
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];

            const values = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };

            if (targetPiece) {
                score += values[targetPiece.toLowerCase()] * 10;
            }

            const centerDistance = Math.abs(toRow - 3.5) + Math.abs(toCol - 3.5);
            score += (7 - centerDistance);

            if (piece.toLowerCase() !== 'p' && fromRow === (botColor === 'white' ? 7 : 0)) {
                score += 2;
            }

            return score;
        }

        function wouldBeInCheck(fromRow, fromCol, toRow, toCol, isWhite) {
            const originalPiece = board[toRow][toCol];
            const movingPiece = board[fromRow][fromCol];
            
            board[toRow][toCol] = movingPiece;
            board[fromRow][fromCol] = '';

            const inCheck = isKingInCheck(isWhite);

            board[fromRow][fromCol] = movingPiece;
            board[toRow][toCol] = originalPiece;

            return inCheck;
        }

        function isKingInCheck(isWhite) {
            let kingRow, kingCol;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.toLowerCase() === 'k' && isWhitePiece(piece) === isWhite) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
            }

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isWhitePiece(piece) !== isWhite) {
                        const moves = getPieceMoves(row, col, piece);
                        if (moves.some(([r, c]) => r === kingRow && c === kingCol)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function getPieceMoves(row, col, piece) {
            const isWhite = isWhitePiece(piece);
            const pieceType = piece.toLowerCase();

            switch (pieceType) {
                case 'p': return getPawnMoves(row, col, isWhite);
                case 'r': return getRookMoves(row, col, isWhite);
                case 'n': return getKnightMoves(row, col, isWhite);
                case 'b': return getBishopMoves(row, col, isWhite);
                case 'q': return getQueenMoves(row, col, isWhite);
                case 'k': return getKingMoves(row, col, isWhite);
                default: return [];
            }
        }

        function hasValidMoves(isWhite) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isWhitePiece(piece) === isWhite) {
                        if (getValidMoves(row, col).length > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function isCheckmate(color) {
            const isWhite = color === 'white';
            return isKingInCheck(isWhite) && !hasValidMoves(isWhite);
        }

        function isStalemate(color) {
            const isWhite = color === 'white';
            return !isKingInCheck(isWhite) && !hasValidMoves(isWhite);
        }

        function isInsufficientMaterial() {
            const pieces = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        pieces.push({ type: piece.toLowerCase(), isWhite: isWhitePiece(piece), row, col });
                    }
                }
            }

            if (pieces.length === 2) {
                return true;
            }

            if (pieces.length === 3) {
                const nonKings = pieces.filter(p => p.type !== 'k');
                if (nonKings.length === 1 && (nonKings[0].type === 'b' || nonKings[0].type === 'n')) {
                    return true;
                }
            }

            if (pieces.length === 4) {
                const bishops = pieces.filter(p => p.type === 'b');
                if (bishops.length === 2) {
                    const bishop1Color = (bishops[0].row + bishops[0].col) % 2;
                    const bishop2Color = (bishops[1].row + bishops[1].col) % 2;
                    if (bishop1Color === bishop2Color) {
                        return true;
                    }
                }
            }

            return false;
        }

        function checkGameEnd() {
            const messageEl = document.getElementById('message');
            
            if (isInsufficientMaterial()) {
                stopTimer();
                messageEl.textContent = '‚öñÔ∏è Draw! Insufficient Material!';
                messageEl.className = 'message';
                document.getElementById('status').textContent = 'Game Over';
                currentTurn = 'none';
                showGameOverModal('insufficient', null);
                return;
            }
            
            if (isCheckmate('white')) {
                stopTimer();
                if (opponentType === 'friend') {
                    messageEl.textContent = `üèÜ ${player2DisplayName} Wins! Checkmate!`;
                    showGameOverModal('checkmate', player2DisplayName);
                } else {
                    const winner = playerColor === 'black' ? player1DisplayName : 'Bot';
                    messageEl.textContent = playerColor === 'black' ? 
                        `üèÜ ${player1DisplayName} Wins! Checkmate!` : 
                        'üèÜ Bot Wins! Checkmate!';
                    showGameOverModal('checkmate', winner);
                }
                messageEl.className = 'message checkmate';
                document.getElementById('status').textContent = 'Game Over';
                currentTurn = 'none';
            } else if (isCheckmate('black')) {
                stopTimer();
                if (opponentType === 'friend') {
                    messageEl.textContent = `üèÜ ${player1DisplayName} Wins! Checkmate!`;
                    showGameOverModal('checkmate', player1DisplayName);
                } else {
                    const winner = playerColor === 'white' ? player1DisplayName : 'Bot';
                    messageEl.textContent = playerColor === 'white' ? 
                        `üèÜ ${player1DisplayName} Wins! Checkmate!` : 
                        'üèÜ Bot Wins! Checkmate!';
                    showGameOverModal('checkmate', winner);
                }
                messageEl.className = 'message checkmate';
                document.getElementById('status').textContent = 'Game Over';
                currentTurn = 'none';
            } else if (isStalemate('white') || isStalemate('black')) {
                stopTimer();
                messageEl.textContent = 'ü§ù Draw! Stalemate!';
                messageEl.className = 'message';
                document.getElementById('status').textContent = 'Game Over';
                currentTurn = 'none';
                showGameOverModal('stalemate', null);
            }
        }

        function updateStatus() {
            const turnIndicator = document.getElementById('turnIndicator');
            const status = document.getElementById('status');
            
            if (opponentType === 'friend') {
                const currentPlayerName = currentTurn === 'white' ? player1DisplayName : player2DisplayName;
                turnIndicator.textContent = `${currentPlayerName}'s Turn`;
                status.textContent = isKingInCheck(currentTurn === 'white') ? 'Check!' : 'Game in Progress';
            } else {
                if (currentTurn === playerColor) {
                    if (player1DisplayName === 'You') {
                        turnIndicator.textContent = "Your Turn";
                    } else {
                        turnIndicator.textContent = `${player1DisplayName}'s Turn`;
                    }
                    status.textContent = isKingInCheck(playerColor === 'white') ? 'Check!' : 'Game in Progress';
                } else if (currentTurn !== 'none') {
                    turnIndicator.textContent = "Bot's Turn";
                    status.textContent = isKingInCheck(botColor === 'white') ? 'Check!' : 'Game in Progress';
                }
            }
        }

        function updateCapturedPieces() {
            document.getElementById('whiteCaptured').textContent = 
                capturedPieces.white.map(p => PIECES[p]).join(' ') || '-';
            document.getElementById('blackCaptured').textContent = 
                capturedPieces.black.map(p => PIECES[p]).join(' ') || '-';
        }

        function undoMove() {
            playButtonClick();
            if (opponentType === 'friend') {
                if (moveHistory.length < 1) return;
                const lastMove = moveHistory.pop();
                board[lastMove.from[0]][lastMove.from[1]] = lastMove.piece;
                board[lastMove.to[0]][lastMove.to[1]] = lastMove.captured;
                if (lastMove.captured) {
                    const pieces = isWhitePiece(lastMove.captured) ? capturedPieces.black : capturedPieces.white;
                    pieces.pop();
                }
                currentTurn = lastMove.turn;
                moveCount--;
            } else {
                if (moveHistory.length < 2) return;

                const botMove = moveHistory.pop();
                board[botMove.from[0]][botMove.from[1]] = botMove.piece;
                board[botMove.to[0]][botMove.to[1]] = botMove.captured;
                if (botMove.captured) {
                    const pieces = isWhitePiece(botMove.captured) ? capturedPieces.black : capturedPieces.white;
                    pieces.pop();
                }
                moveCount--;

                const playerMove = moveHistory.pop();
                board[playerMove.from[0]][playerMove.from[1]] = playerMove.piece;
                board[playerMove.to[0]][playerMove.to[1]] = playerMove.captured;
                if (playerMove.captured) {
                    const pieces = isWhitePiece(playerMove.captured) ? capturedPieces.black : capturedPieces.white;
                    pieces.pop();
                }
                moveCount--;

                currentTurn = playerColor;
            }
            
            lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
            selectedSquare = null;
            renderBoard();
            updateStatus();
            updateCapturedPieces();
            updateMoveCounter();
            document.getElementById('message').textContent = '';
        }

        function newGame() {
            playButtonClick();
            stopTimer();
            document.getElementById('setupPanel').classList.remove('hidden');
            document.getElementById('gamePanel').classList.remove('active');
            document.getElementById('timerDisplay').classList.remove('active');
            document.getElementById('botThinking').classList.remove('active');
        }
    </script>
</body>
</html>
